<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <title>Raw SVG formatter</title>
  <script src="https://unpkg.com/vue@2.5.16/dist/vue.js"></script>
  <script src="https://unpkg.com/jquery@3.3.1/dist/jquery.js"></script>
  <link rel="stylesheet" type="text/css" href="https://unpkg.com/jstree@3.3.5/dist/themes/default/style.min.css">
  <script src="https://unpkg.com/jstree@3.3.5/dist/jstree.js"></script>
  <script src="https://unpkg.com/filesaver.js@1.3.4/FileSaver.js"></script>
  <script src="test.js"></script>
  <style type="text/css">
    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    #app {
      height: 100%;
      display: flex;
      flex-direction: column;
      padding: 15px;
    }

    #app p,
    fieldset legend,
    #config {
      font-family: sans-serif;
    }

    html {
      width: 100%;
      height: 100%;
      border: 3px solid transparent;
    }

    html.dropover {
      border-color: #333388;
    }

    #svg-holder {
      position: relative;
      width: 50vh;
      height: 50vh;
    }

    #svg-holder svg {
      width: 100%;
      height: 100%;
    }

    #svg-holder #strokeStarts {
      position: absolute;
      pointer-events: none;
      left: 0;
      top: 0;
      display: none;
    }

    #svg-holder.show-starting-points #strokeStarts {
      display: inline-block;
    }

    #svg-holder svg text {
      font-size: 8px !important;
    }

    #svg-holder svg .active,
    #svg-holder svg .active path {
      stroke: #ff0000 !important;
    }

    #svg-holder svg text.active,
    #svg-holder svg .active text {
      fill: #ff0000 !important;
      stroke: none !important;
    }

    #svg-holder svg .highlighted,
    #svg-holder svg .highlighted path,
    #svg-holder svg .active.highlighted path,
    #svg-holder svg .active.highlighted,
    #svg-holder svg .active *.highlighted {
      stroke: #00ff00 !important;
    }

    #svg-holder svg text.highlighted,
    #svg-holder svg .active.highlighted text,
    #svg-holder svg text.active.highlighted,
    #svg-holder svg .highlighted text,
    #svg-holder svg .active text.highlighted,
    #svg-holder svg .active.highlighted text {
      fill: #00ff00 !important;
      stroke: none !important;
    }

    .flex {
      display: flex;
    }

    .flex-half {
      width: 50%;
      flex-grow: 1;
      flex-shrink: 1;
    }

    #panel {
      background-color: #eee;
      padding: 5px 10px;
    }

    #config dl {
      display: flex;
      flex-wrap: wrap;
    }

    #config dt {
      width: 30%;
    }

    #config dd {
      width: 70%;
      margin: 0;
    }

    #config dt,
    #config dd {
      margin-bottom: 7px;
    }

    #config dd input[type="text"],
    #config dd input[type="number"],
    #config dd select {
      width: 100%;
    }

    #tree .tree-icon-group {
      background-image: url('https://connum.github.io/hanzivg/ico/ico_group.svg');
      background-size: contain;
    }

    #tree .tree-icon-stroke {
      background-image: url('https://connum.github.io/hanzivg/ico/ico_stroke.svg');
      background-size: contain;
    }

    #tree .tree-icon-group-num {
      background-image: url('https://connum.github.io/hanzivg/ico/ico_group_num.svg');
      background-size: contain;
    }

    #tree .tree-icon-number {
      background-image: url('https://connum.github.io/hanzivg/ico/ico_number.svg');
      background-size: contain;
    }

    .infolink {
      background-color: #000088;
      color: #fff;
      border-radius: 50%;
      display: inline-block;
      float: right;
      text-decoration: none;
      text-align: center;
      font-size: 0.8em;
      font-weight: 700;
      width: 1.4em;
      height: 1.4em;
      line-height: 1.5em;
      vertical-align: middle;
    }

    .disabled {
      opacity: 0.2;
      pointer-events: none;
      cursor: not-allowed;
    }

    .jstree-anchor,
    #panel input,
    #panel select,
    #eventlog {
      font-family: stheiti, simhei, sans-serif, sans-serif;
    }

    #eventlog {
      width: 100%;
      flex-grow: 1;
      overflow: auto;
    }

    #eventlog ol {
      list-style-type: none;
      margin: 0;
      padding: 0;
    }

    #eventlog ol li {
      padding: 3px 6px;
      margin: 3px 0px;
      background: #eee;
    }

    #eventlog ol li.warn {
      background: #fffbd5;
    }

    #eventlog ol li.success {
      background: #dbffc5;
    }

    #eventlog ol li.info {
      background: #d5dbff;
    }

    #eventlog ol li.error {
      background: #ffc5c5;
    }

    #eventlog .highlighter:hover {
      cursor: pointer;
      text-decoration: underline;
    }
  </style>
</head>

<body>
  <div id="app">
    <p><strong>This tool will convert raw SVG files created from the template to final HanziVG SVG files and allow for
        creating and editing stroke order, groups and group metadata.<br>Exporting is not yet implemented.</strong></p>
    <p v-if="!node_data">Drag &amp; drop SVG in this window</p>
    <p v-else><button
        @click="!preview ? playPreview() : stopPreview()">{{ !preview ? 'Play Preview' : 'Stop Preview'}}</button>
      <label><input type="checkbox" v-model="showStartingPoints"> show starting points</label> <button
        @click="exportSVG" :disabled="preview">Export</button></p>
    <main class="flex" v-show="node_data">
      <fieldset id="preview" class="flex-half">
        <legend>Preview</legend>
        <div id="svg-holder" :class="{'show-starting-points': showStartingPoints}"></div>
      </fieldset>
      <fieldset id="config" class="flex-half" :class="{disabled: preview}">
        <legend>Config</legend>
        <div class="flex">
          <div id="tree" class="flex-half">
          </div>
          <div id="panel" class="flex-half" v-if="selected_node">
            <button @click="addGroup" v-if="selected_node.tree.type==='path' || selected_node.tree.type==='g'">add
              group</button>
            <button @click="removeGroup"
              v-if="selected_node.tree.type==='g' && selected_node.preview.parentNode.parentNode.tagName !== 'svg'">remove
              group</button>
            <a class="infolink" href="http://kanjivg.tagaini.net/format.html" target="_blank" title="format information"
              v-if="selected_node.preview.parentNode.tagName !== 'svg' && selected_node.tree.type !== 'text'">?</a>
            <dl>
              <template v-if="selected_node.preview.id">
                <dt>ID:</dt>
                <dd>{{selected_node.preview.id}}</dd>
              </template>
              <template
                v-if="/^[kh]vg:Stroke(Paths|Numbers)_/.test(selected_node.tree.text) || selected_node.tree.type === 'text'">
                <dt>character code:</dt>
                <dd>{{charId}}</dd>
                <dt>radical + strokes:</dt>
                <dd>{{calcRadicalStrokes()}}</dd>
                <dt>run tests again:</dt>
                <dd><button @click="runTests">run</button></dd>
              </template>
              <template v-if="selected_node.tree.type == 'g'">
                <dt>Element:</dt>
                <dd><input type="text" :value="selected_node.preview.getAttribute('kvg:element')"
                    @input="updateElAttr(selected_node, 'kvg:element', $event)" /></dd>
                <dt>Original:</dt>
                <dd><input type="text" :value="selected_node.preview.getAttribute('kvg:original')"
                    @input="updateElAttr(selected_node, 'kvg:original', $event)" /></dd>
                <dt>Position:</dt>
                <dd><select :value="selected_node.preview.getAttribute('kvg:position')"
                    @change="updateElAttr(selected_node, 'kvg:position', $event)">
                    <option></option>
                    <option>left</option>
                    <option>right</option>
                    <option>top</option>
                    <option>bottom</option>
                    <option>nyo</option>
                    <option>tare</option>
                    <option>kamae</option>
                    <option>kamae1</option>
                    <option>kamae2</option>
                  </select></dd>
                <dt>Variant:</dt>
                <dd><input type="checkbox" :checked="selected_node.preview.getAttribute('kvg:variant')"
                    @input="updateElAttr(selected_node, 'kvg:variant', $event)" /></dd>
                <dt>Partial:</dt>
                <dd><input type="checkbox" :checked="selected_node.preview.getAttribute('kvg:partial')"
                    @input="updateElAttr(selected_node, 'kvg:partial', $event)" /></dd>
                <template v-if="selected_node.preview.getAttribute('kvg:part')">
                  <dt>Part:</dt>
                  <dd><input type="number" :value="selected_node.preview.getAttribute('kvg:part')"
                      @input="updateElAttr(selected_node, 'kvg:part', $event)" /></dd>
                </template>
                <dt>Number:</dt>
                <dd><input type="number" :value="selected_node.preview.getAttribute('kvg:number')"
                    @input="updateElAttr(selected_node, 'kvg:number', $event)" /></dd>
                <dt>Radical:</dt>
                <dd><select :value="selected_node.preview.getAttribute('kvg:radical')"
                    @change="updateElAttr(selected_node, 'kvg:radical', $event)">
                    <option></option>
                    <option>general</option>
                    <option>nelson</option>
                    <option>tradit</option>
                  </select></dd>
                <dt>Phon:</dt>
                <dd><input type="text" :value="selected_node.preview.getAttribute('kvg:phon')"
                    @input="updateElAttr(selected_node, 'kvg:phon', $event)" /></dd>
                <dt>tradForm:</dt>
                <dd><input type="text" :value="selected_node.preview.getAttribute('kvg:tradForm')"
                    @input="updateElAttr(selected_node, 'kvg:tradForm', $event)" /></dd>
                <dt>radicalForm:</dt>
                <dd><input type="text" :value="selected_node.preview.getAttribute('kvg:radicalForm')"
                    @input="updateElAttr(selected_node, 'kvg:radicalForm', $event)" /></dd>
              </template>
              <template v-if="selected_node.tree.type == 'path'">
                <dt>Type:</dt>
                <dd>
                  <select
                    :value="selected_node.preview.getAttribute('kvg:type') ? selected_node.preview.getAttribute('kvg:type')[0] : ''"
                    @change="updateElAttr(selected_node, 'kvg:type', $event), $event.target.nextElementSibling.value = $event.target.value">
                    <option v-for="s in strokeTypes">{{ s }}</option>
                  </select>
                  <input type="text" :value="selected_node.preview.getAttribute('kvg:type')"
                    @input="updateElAttr(selected_node, 'kvg:type', $event)" /></dd>
              </template>
            </dl>
          </div>
        </div>
      </fieldset>
    </main>
    <fieldset id="eventlog" v-show="node_data">
      <legend>Event Log</legend>
      <ol>
        <li v-for="(event, eix) in eventLog" :class="event.type || 'warn'" v-html="" :key="eix">
          <template v-if="event.context === 'test' && event.type === 'error'">TEST FAILED: </template><template
            v-if="event.elements && event.elements.length">[</template><template v-for="(el, elix) in event.elements"
            v-if="el"><span class="highlighter" @click="logClick(el)" @mouseover="logHoverStart(el)"
              @mouseout="logHoverEnd(el)">#{{el.id}}</span><template v-if="elix < event.elements.length - 1">,
            </template></template><template v-if="event.elements && event.elements.length">]:<br></template>
          <span v-html="event.message"></span></li>
      </ol>
    </fieldset>
  </div>
  <script type="text/javascript">
    /*
     * the following two functions have been taken from
     * https://stackoverflow.com/questions/21647928/javascript-unicode-string-to-hex/26375459#answer-21648161
     */
    String.prototype.hexEncode = function () {
      var hex, i;

      var result = "";
      for (i = 0; i < this.length; i++) {
        hex = this.charCodeAt(i).toString(16);
        result += ("000" + hex).slice(-4);
      }

      return result
    }
    String.prototype.hexDecode = function () {
      var j;
      var hexes = this.match(/.{1,4}/g) || [];
      var back = "";
      for (j = 0; j < hexes.length; j++) {
        back += String.fromCharCode(parseInt(hexes[j], 16));
      }

      return back;
    }

    var app = new Vue({
      el: '#app',
      data: function () {
        return {
          isDirty: false,
          charId: 'XXXXX',
          node_data: null,
          selected_node: null,
          nodeCounts: {
            group: 0,
            stroke: 0
          },
          strokeTypes: [
            '㇔', '㇐', '㇑', '㇒', '㇏', '㇀', '㇖', '㇚', '㇂', '㇙', '㇕', '㇗', '㇛', '㇜', '㇇', '㇄', '㇆', '㇟', '㇊', '㇉', '㇋', '㇌', '㇈', '㇅', '㇞', ']'
          ],
          preview: false,
          previewTimeouts: [],
          showStartingPoints: true,
          eventLog: []
        }
      },
      computed: {
      },
      methods: {
        runTests: window.HANZIVG_runTests
          ?
          (ev) => {
            if (ev) {
              this.logEvent({
                message: 'running tests...',
                type: 'info'
              })
            }
            var svg = $('#svg-holder svg').first()[0];
            window.HANZIVG_runTests(svg, app);
            if (ev) {
              if (svg.errorCount === 0) {
                this.logEvent({
                  message: 'Tests finished without any issues.',
                  type: 'success'
                })
              } else {
                this.logEvent({
                  message: 'There are still ' + svg.errorCount + ' issues',
                  type: 'error'
                })
              }
            }
          }
          :
          function () {
            this.logEvent({
              message: 'Global function runTests() not available! Automatic testing not possible.',
              type: 'error'
            });
          }
        ,
        logEvent: function (data) {
          this.eventLog.push(data);
          this.$nextTick(function () {
            var lastLog = document.querySelector('#eventlog li:last-child');
            if (lastLog) {
              lastLog.scrollIntoView();
            }
          });
        },
        logHoverStart: function (node) {
          node.classList.add('highlighted');
        },
        logHoverEnd: function (node) {
          node.classList.remove('highlighted');
        },
        logClick: function (node) {
          var $jstree = $('#tree').jstree();
          var that = this;
          this.getFlatJsTree().each(function () {
            if (this.data.svgNode === node) {
              $jstree.open_node(this);
              that.$nextTick(() => {
                $jstree.select_node(this);
              })
            } else {
              $jstree.deselect_node(this);
            }
          });

        },
        calcRadicalStrokes: function () {
          var $svg = $('#svg-holder svg').first(),
            radicalsByType = {
              _other: []
            },
            totalStrokes = $svg.find('path').length,
            radicals = $svg.find('g').filter(function () {
              var isRadical = this.hasAttribute('kvg:radical');
              if (isRadical) {
                var radicalType = this.getAttribute('kvg:radical');
                if (radicalType) {
                  if (typeof radicalsByType[radicalType] === 'undefined') {
                    radicalsByType[radicalType] = [];
                  }
                  radicalsByType[radicalType].push(this);
                  if (radicalType != 'general') {
                    radicalsByType['_other'].push(this);
                  }
                }
              }
              return this.hasAttribute('kvg:radical');
            });
          var radicalGroup = (radicalsByType.general && radicalsByType.general.length ? radicalsByType.general[0] : (radicalsByType.tradit && radicalsByType.tradit.length ? radicalsByType.tradit[0] : (radicalsByType._other && radicalsByType._other.length ? radicalsByType._other[0] : null)));
          if (radicalGroup) {
            var radical = radicalGroup.getAttribute('kvg:element'),
              radicalOriginal = radicalGroup.getAttribute('kvg:original'),
              radicalStrokes = $(radicalGroup).find('path').length;
            if (radicalGroup.hasAttribute('kvg:number') || radicalGroup.hasAttribute('kvg:part')) {
              var additionalGroups = radicals.filter(function () {
                return this != radicalGroup && this.getAttribute('kvg:element') === radical && this.getAttribute('kvg:number') === radicalGroup.getAttribute('kvg:number');
              });
              radicalStrokes += (additionalGroups.find('path').length);
            }
          }
          return (radicalOriginal ? radicalOriginal + '/' : '') + (radical || '?') + ' + ' + (totalStrokes - (radicalStrokes || 0));
        },
        onDragLeave: function () {
          document.documentElement.classList.remove('dropover')
        },
        onDragOver: function (ev) {
          ev.preventDefault()
          document.documentElement.classList.add('dropover')
        },
        onDrop: function (ev) {
          ev.preventDefault();

          let file = ev.dataTransfer.files[0]
          let fileReader = new FileReader()

          if (this.isDirty && !confirm('Unsaved changes will be lost! Continue?')) {
            this.onDragLeave();
            return;
          }
          this.isDirty = false;

          this.eventLog = [];
          this.logEvent({
            message: 'File "' + file.name + '" dropped.',
            type: 'info'
          })

          fileReader.addEventListener('load', this.onFileLoaded)
          fileReader.readAsText(file)

          var fileNameMatch = file.name.match(/^[0-9a-f]{5}/i);
          if (fileNameMatch) {
            this.charId = fileNameMatch[0];
          }

          this.onDragLeave()
        },
        onFileLoaded: function (ev) {
          this.handleInput((new DOMParser()).parseFromString(ev.target.result, 'image/svg+xml'));
        },
        handleInput: function (xml) {
          var $tree = $('#tree')
          var that = this;

          var holder = document.getElementById('svg-holder'),
            $holder = $(holder);

          $holder.find('svg').remove();
          holder.appendChild(xml.children[0])

          var $svg = $holder.find('svg').first();

          if (!$svg.find('g').length) {
            $svg.find('path').wrapAll(
              $(this.svgEl('g'))
                .attr('id', 'hvg:StrokePaths_' + this.charId)
                .attr('style', 'fill:none;stroke:#000000;stroke-width:3;stroke-linecap:round;stroke-linejoin:round;')
            );
            $svg.find('path').wrapAll(
              $(this.svgEl('g'))
                .attr('id', 'hvg:' + this.charId)
                .attr('kvg:element', String.fromCharCode(parseInt(this.charId, 16)))
            );
            $svg.find('text').wrapAll(
              $(this.svgEl('g'))
                .attr('id', 'hvg:StrokeNumbers_' + this.charId)
                .attr('style', 'font-size:8;fill:#808080')
            );
          }

          strokeStarts = this.svgEl('svg');
          strokeStarts.setAttribute('width', '109');
          strokeStarts.setAttribute('height', '109');
          strokeStarts.setAttribute('viewBox', '0 0 109 109');
          strokeStarts.id = 'strokeStarts';
          holder.appendChild(strokeStarts);

          // clean styles
          var fixed = false;
          $svg.find('text, path').each(function () {
            var svgNode = this;
            if (svgNode.hasAttribute('style')) {
              svgNode.removeAttribute('style');
              that.logEvent({ message: 'FIX: removed style attribute', element: svgNode });
              fixed = true;
            }
            if (svgNode.tagName === 'text' && svgNode.hasAttribute('id')) {
              svgNode.removeAttribute('id')
              that.logEvent({ message: 'FIX: removed id attribute', element: svgNode });
              fixed = true;
            }
            $(svgNode.attributes).each(function (k, attr) {
              if (/:/.test(attr.name) && !/^kvg:/.test(attr.name)) {
                svgNode.removeAttribute(attr.name);
                if (attr.name != 'xmlns:kvg') {
                  that.logEvent({ message: 'FIX: removed ' + attr.name + ' attribute', element: svgNode });
                  fixed = true;
                }
              }
            });
            if (svgNode.tagName === 'path') {
              var pathStart = svgNode.getAttribute('d').match(/^[M]\s*(-?[\d\.]+)[ ,](-?[\d\.]+)[a-z\s]/i),
                startPoint = that.svgEl('circle');
              startPoint.setAttribute('cx', pathStart[1]);
              startPoint.setAttribute('cy', pathStart[2]);
              startPoint.setAttribute('r', '1.5');
              startPoint.setAttribute('fill', '#ff00ff');
              startPoint.setAttribute('stroke', 'none');
              strokeStarts.appendChild(startPoint);
            }
          });

          $svg.find('[id]').each(function () {
            if (!(new RegExp('^[hk]vg:(StrokePaths_|StrokeNumbers_)?' + that.charId)).test(this.id)) {
              var newId = this.id.replace(/^[hk]vg:(StrokePaths_|StrokeNumbers_)?[0-9a-fX]{5}/, 'hvg:$1' + that.charId);
              that.logEvent({ message: 'FIX: id "' + this.id + '" did not match character code, renamed to "' + newId + '"', element: this });
              fixed = true; // trigger renaming
              this.id = newId;
            }

            var allEls = Array.from($svg.find(this.tagName + ':not(svg > g, svg > g > g)')),
              elIdx = allEls.indexOf(this);
            if (elIdx >= 0 && !(new RegExp('-[^d]+' + (elIdx + 1) + '$')).test(this.getAttribute('id'))) {
              var oldId = this.id,
                newId = this.id.replace(/-([^\d]+)\d+$/, '-$1' + (elIdx + 1));
              this.id = newId;
              that.logEvent({ message: 'FIX: id did not match node position, renamed id "' + oldId + '" to "' + newId + '"', element: this });
              fixed = true
            }
          });

          $svg.find('[id^="kvg:StrokeNumbers_"], [id^="hvg:StrokeNumbers_"]').each(function () {
            var sa = this.getAttribute('style');
            newStyle = sa ? sa.replace(/(font-size:)([^;]+)/, '$18') : 'font-size:8;fill:#808080';
            if (!sa) {
              this.setAttribute('style', newStyle);
              fixed = true;
              that.logEvent({ message: 'FIX: set default style attribute', element: this });
            } else if (newStyle != sa) {
              this.setAttribute('style', newStyle);
              fixed = true;
              that.logEvent({ message: 'FIX: corrected font-size property on StrokeNumbers group', element: this });
            }
          });

          if (fixed) {
            this.makeDirty();
          }

          this.node_data = this.xmlToJsTree($svg[0]);
          this.selected_node = null;
          this.nodeCounts = {
            group: 0,
            stroke: 0
          };

          if ($tree.hasClass('jstree')) {
            $tree.jstree("destroy")
          }
          $tree.jstree({
            plugins: ["dnd", "types"],
            core: {
              check_callback: true,
              multiple: false,
              data: this.node_data.children
            },
            dnd: {
              inside_pos: 'last'
            },
            types: {
              '#': {
                max_children: 2,
                valid_children: ['g']
              },
              'g': {
                valid_children: ['g', 'path'],
                icon: 'tree-icon-group'
              },
              'path': {
                max_children: 0,
                valid_children: [],
                icon: 'tree-icon-stroke'
              },
              'text': {
                max_children: 0,
                valid_children: [],
                icon: 'tree-icon-number'
              },
              '_strokes': {
                max_children: 1,
                valid_children: ['g'],
                icon: 'tree-icon-group'
              },
              '_numbers': {
                valid_children: ['text'],
                icon: 'tree-icon-group-num'
              }
            }
          }).on('hover_node.jstree', function (e, data) {
            data.node.data.svgNode.classList.add('highlighted');
          }).on('dehover_node.jstree', function (e, data) {
            data.node.data.svgNode.classList.remove('highlighted');
          }).on('select_node.jstree', function (e, data) {
            $('#svg-holder .active').removeClass('active');
            data.node.data.svgNode.classList.add('active');
            that.selected_node = {
              preview: data.node.data.svgNode,
              tree: data.node
            };
          }).on('deselect_node.jstree', function (e, data) {
            data.node.data.svgNode.classList.remove('active');
            that.selected_node = null;
          }).on('move_node.jstree', function (e, data) {
            var $jstree = $tree.jstree();
            // $(data.parent.data.svgNode)
            // $(data.node.data.svgNode).insertAfter()
            var parent = $jstree.get_node(data.parent),
              p_parent = parent.data.svgNode,
              p_node = data.node.data.svgNode;
            if (data.position === 0) {
              p_parent.prepend(p_node);
            } else {
              $('#preview .highlighted').removeClass('highlighted');
              $(p_node).insertAfter(p_parent.children[data.position - 1]);
            }

            $jstree.open_node(parent);

            if (data.node.type !== 'text') {
              that.reorderGroups();
              that.reorderStrokes();
            } else {
              that.reorderNumbers();
            }
          }).on('delete_node.jstree', function (e, data) {
            e, data.node.data.svgNode.remove();
          });

          // open and select main character node
          var $jstree = $tree.jstree(),
            $treenodes = $jstree.get_json();
          $jstree.open_node($treenodes[0]);
          if ($treenodes[0].children.length) {
            $jstree.open_node($treenodes[0].children[0]);
            $jstree.select_node($treenodes[0].children[0]);
          }

          this.$nextTick(() => {
            this.runTests();
            var testErrors = $svg[0].errorCount && $svg[0].errorCount > 0;
            if (!this.isDirty && !testErrors) {
              this.logEvent({
                message: 'Processed input SVG without any issues.',
                type: 'success'
              })
            } else if (testErrors) {
              this.logEvent({
                message: '<strong>There are errors in this SVG that could not be fixed automatically. Please edit the SVG file and load it again.</strong>',
                type: 'error'
              })
            }
          });
        },
        xmlToJsTree(xmlNode) {
          if (xmlNode.tagName == 'text') {
            xmlNode.removeAttribute('tagName');
          } else if (!/^[kh]vg:/.test(xmlNode.id)) {
            if (xmlNode.tagName == 'g') {
              this.nodeCounts.group++;
              var typeCountId = '-g' + this.nodeCounts.group;
            } else if (xmlNode.tagName == 'path') {
              this.nodeCounts.stroke++;
              var typeCountId = '-s' + this.nodeCounts.stroke;
            }
            if (typeCountId) {
              xmlNode.id = 'hvg:' + this.charId + typeCountId;
            }
          }

          var label = xmlNode.id;
          var firstChild = xmlNode.children[0] || xmlNode.firstChild;

          label += this.getLabelSuffix(xmlNode)

          var treeNode = {
            text: firstChild && firstChild.nodeType === 3 ?
              firstChild.textContent : label,
            data: { svgNode: xmlNode },
            type: /^[kh]vg:StrokeNumbers/.test(xmlNode.id) ? '_numbers' : (/^[kh]vg:StrokePaths/.test(xmlNode.id) ? '_strokes' : xmlNode.tagName),
            children: [...xmlNode.children].filter(function (childNode) {
              var isSupportedElement = ['g', 'path', 'text'].includes(childNode.tagName);
              if (!isSupportedElement) {
                childNode.parentNode.removeChild(childNode)
              }
              return isSupportedElement
            }).map(childNode => this.xmlToJsTree(childNode))
          };

          return treeNode;
        },
        makeDirty() {
          this.isDirty = true;
          var that = this,
            kvgIds = $('#preview svg [id^="kvg:"]');
          if (kvgIds.length) {
            kvgIds.each(function () {
              this.id = this.id
                .replace(/^kvg:/, 'hvg:')
                .replace(new RegExp(that.charId + '-(VtLst|HyougaiKaisho|KaishoVt3|HzFst|Insatsu|MidFst|KaishoVtLst|Kaisho|Jinmei|Hyougai|KaishoVt4)'), that.charId);
            });
            var $jstree = $('#tree').jstree();
            this.getFlatJsTree().each(function (index, value) {
              if (this.type == 'text' || !/^kvg:/.test(this.text)) return true;
              $jstree.rename_node(this,
                this.text
                  .replace(/^kvg:/, 'hvg:')
                  .replace(new RegExp(that.charId + '-(VtLst|HyougaiKaisho|KaishoVt3|HzFst|Insatsu|MidFst|KaishoVtLst|Kaisho|Jinmei|Hyougai|KaishoVt4)'), that.charId)
              );
            });
          }
        },
        updateElAttr(el, attr, ev) {
          this.makeDirty();
          var val = $(ev.target).val();
          if (ev.target.type === 'checkbox') {
            val = ev.target.checked;
          }
          if (!val) {
            el.preview.removeAttribute(attr, val);
          } else {
            el.preview.setAttribute(attr, val);
          }

          if (attr === 'kvg:element' || attr === 'kvg:type') {
            $('#tree').jstree('rename_node', el.tree, el.preview.id + this.getLabelSuffix(el.preview));
          }
        },
        svgEl(tag) {
          return document.createElementNS('http://www.w3.org/2000/svg', tag);
        },
        addGroup() {
          this.makeDirty();
          var $tree = $('#tree'),
            t_node = this.selected_node.tree,
            p_node = this.selected_node.preview,
            $jstree = $tree.jstree();

          var newPreviewGroup = this.svgEl('g');

          if (t_node.type == 'g') {
            var t_parent = t_node;
            var p_parent = p_node;
            var this_index = 'first';
            p_node.prepend(newPreviewGroup);
          } else {
            var t_parent = $jstree.get_node($jstree.get_parent(t_node));
            var p_parent = p_node.parentNode;
            var this_index = $.inArray(t_node.id, t_parent.children);
            $(p_node).wrapAll(newPreviewGroup);
          }

          var newTreeGroup = $jstree.create_node(t_parent, {
            type: 'g',
            data: {
              svgNode: t_node.type == 'g' ? p_node.children[0] : p_node.parentNode
            },
          }, this_index > 0 ? this_index : 0);

          // p_node.parentNode._treeNode = 

          $jstree.move_node(t_node, newTreeGroup);
          $jstree.open_node([t_node, newTreeGroup]);
          $jstree.deselect_node(t_node);
          $jstree.select_node(newTreeGroup);

          this.reorderGroups();
        },
        removeGroup() {
          this.makeDirty();
          var $tree = $('#tree'),
            $jstree = $tree.jstree(),
            t_node = this.selected_node.tree,
            t_parent = $jstree.get_node(t_node.parent),
            p_node = this.selected_node.preview,
            $p_node = $(p_node);

          this.selected_node = null;
          if (t_node.children.length) {
            var firstChild = $jstree.get_node(t_node.children[0]);
            $jstree.move_node(t_node.children.slice(0), t_parent, $.inArray(t_node.id, t_parent.children));
            $jstree.select_node(firstChild);
          }
          $jstree.delete_node(t_node);

          this.reorderGroups();
        },
        getFlatJsTree() {
          var $tree = $('#tree'),
            $jstree = $tree.jstree();
          return $($jstree.get_json($tree, {
            flat: true
          }));
        },
        reorderGroups() {
          this.makeDirty();
          var $tree = $('#tree'),
            $jstree = $tree.jstree(),
            groupIndex = 0,
            that = this;

          this.getFlatJsTree().each(function (index, value) {
            var node = $jstree.get_node(this.id),
              p_node = node.data.svgNode;
            if (node.type != 'g' || p_node.parentNode.tagName === 'svg' || p_node.id === 'hvg:' + that.charId) {
              return true;
            }
            groupIndex++;
            var newId = 'hvg:' + that.charId + '-g' + groupIndex;
            $jstree.rename_node(node, newId + that.getLabelSuffix(p_node));
            p_node.id = newId;
          });
        },
        reorderStrokes() {
          this.makeDirty();
          var $tree = $('#tree'),
            $jstree = $tree.jstree(),
            strokeIndex = 0,
            that = this;

          this.getFlatJsTree().each(function (index, value) {
            var node = $jstree.get_node(this.id),
              p_node = node.data.svgNode;
            if (node.type != 'path') {
              return true;
            }
            strokeIndex++;
            var newId = 'hvg:' + that.charId + '-s' + strokeIndex;
            $jstree.rename_node(node, newId + that.getLabelSuffix(p_node));
            p_node.id = newId;
          });
        },
        reorderNumbers() {
          this.makeDirty();
          var $tree = $('#tree'),
            $jstree = $tree.jstree(),
            numberIndex = 0,
            that = this;

          this.getFlatJsTree().each(function (index, value) {
            var node = $jstree.get_node(this.id),
              p_node = node.data.svgNode;
            if (node.type != 'text') {
              return true;
            }
            numberIndex++;
            $jstree.rename_node(node, numberIndex);
            p_node.textContent = numberIndex;
          });
        },
        getLabelSuffix(node) {
          var suffix = (node.tagName === 'path' ? node.getAttribute('kvg:type') : node.getAttribute('kvg:element')) || '';

          if (suffix) {
            suffix = ' (' + suffix + ')';
          }

          return suffix;
        },
        playPreview() {
          this.preview = true;
          var $svg = $('#svg-holder svg').first(),
            $nums = $svg.find('[id^="kvg:StrokeNumbers_' + this.charId + '"], [id^="hvg:StrokeNumbers_' + this.charId + '"]').find('text');
          $svg.find('.active, .highlighted').removeClass('active highlighted');
          for (var i = 0; i <= $nums.length; i++) {
            this.previewTimeouts.push(
              window.setTimeout(((i) => {
                return () => {
                  if (!this.preview) return;
                  if (i >= $nums.length) {
                    this.stopPreview();
                    return;
                  }
                  $svg.find('.highlighted').removeClass('highlighted');
                  $nums.eq(i).add($svg.find('path').eq(i)).addClass('highlighted');
                }
              })(i),
                i * 800)
            );
          }
        },
        stopPreview() {
          this.preview = false;
          $(this.previewTimeouts).each(function () {
            window.clearTimeout(this);
          });
          var $svg = $('#svg-holder svg').first();
          $svg.find('.highlighted').removeClass('highlighted');
        },
        exportSVG() {
          var padding = '\t',
            indent = 0,
            realIndent = 0,
            lastIndent = 0,
            lastWasStrokes = false,
            openTags = [],
            output = '',
            $svg = $('#svg-holder svg').first(),
            $activeEl = $svg.find('.active');
          $svg.find('g,path,text').removeAttr('xmlns:kvg class').each(function () {
            var line = '',
              isStrokes = !!$(this).parents('[id^="kvg:StrokePaths_"],[id^="hvg:StrokePaths_"]').length;
            indent = $(this).parentsUntil('svg').length;

            realIndent = isStrokes ? indent - 1 : indent;

            if (lastIndent > indent) {
              var l = lastIndent - indent;
              for (var i = 0; i < l; i++) {
                var endIndent = lastIndent - i - 1;
                if (isStrokes || lastWasStrokes) endIndent--;
                line += padding.repeat(Math.max(0, endIndent)) + '</' + openTags.shift() + '>\r\n';
              }
            }

            line += padding.repeat(Math.max(0, realIndent));

            line += '<' + this.tagName;
            $(this.attributes).each(function () {
              line += ' ' + this.name + '="' + this.value + '"';
            });

            if (this.tagName == 'path') {
              line += '/>';
            } else if (this.tagName == 'text') {
              line += '>' + this.textContent + '</' + this.tagName + '>';
            } else {
              line += '>';
              openTags.unshift(this.tagName);
            }

            lastIndent = indent;
            lastWasStrokes = isStrokes;

            output += line + '\r\n';
          });

          if (openTags.length) {
            var l = openTags.length;
            for (var i = 0; i < l; i++) {
              realIndent--;
              output += padding.repeat(Math.max(0, realIndent)) + '</' + openTags.shift() + '>\r\n';
            }
          }

          output = `<?xml version="1.0" encoding="UTF-8"?>
<!--
Copyright (C) 2020 HanziVG repository contributors
This work makes an extensive use of kanjiVG Copyright (C) 2009/2010/2011 Ulrich Apel
and AnimHanzi Copyright (C) 2016 François Mizessyn.
This work is distributed under the conditions of the Creative Commons
Attribution-Share Alike 3.0 Licence. This means you are free:
* to Share - to copy, distribute and transmit the work
* to Remix - to adapt the work

Under the following conditions:
* Attribution. You must attribute the work by stating your use of HanziVG in
  your own copyright header and linking to animHanzi's website
  (https://github.com/Connum/HanziVG)
* Attribution. You must attribute the work by stating your use of animHanzi in
  your own copyright header and linking to animHanzi's website
  (http://gooo.free.fr/animHanzi/)
* Attribution. You must attribute the work by stating your use of KanjiVG in
  your own copyright header and linking to KanjiVG's website
  (http://kanjivg.tagaini.net)
* Share Alike. If you alter, transform, or build upon this work, you may
  distribute the resulting work only under the same or similar license to this
  one.

See http://creativecommons.org/licenses/by-sa/3.0/ for more details.
-->
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd" [
<!ATTLIST g
xmlns:kvg CDATA #FIXED "http://kanjivg.tagaini.net"
kvg:element CDATA #IMPLIED
kvg:variant CDATA #IMPLIED
kvg:partial CDATA #IMPLIED
kvg:original CDATA #IMPLIED
kvg:part CDATA #IMPLIED
kvg:number CDATA #IMPLIED
kvg:tradForm CDATA #IMPLIED
kvg:radicalForm CDATA #IMPLIED
kvg:position CDATA #IMPLIED
kvg:radical CDATA #IMPLIED
kvg:phon CDATA #IMPLIED >
<!ATTLIST path
xmlns:kvg CDATA #FIXED "http://kanjivg.tagaini.net"
kvg:type CDATA #IMPLIED >
]>
<svg xmlns="http://www.w3.org/2000/svg" width="109" height="109" viewBox="0 0 109 109">\r\n`
            + output + '</svg>\r\n';

          saveAs(new Blob([output], { type: 'image/svg+xml' }), this.charId + '.svg');

          $activeEl.addClass('active');
        },
        loadFromHash: function () {
          // load file from hash via ajax
          if (location.hash && location.hash.length && (!this.isDirty || confirm('Unsaved changes will be lost! Continue?'))) {
            var filename = location.hash.replace('#', '');
            $.get(filename).done((res) => {
              this.isDirty = false;
              // mark animHanzi files as dirty in order to force namespace renaming
              if (/^animhanzi\//.test(filename)) {
                this.$nextTick(function () {
                  this.logEvent({
                    message: 'Renaming <code>kvg:</code> namespace in id attributes to <code>hvg:</code> in files imported from AnimHanzi',
                    type: 'warn'
                  });
                  this.makeDirty();
                })
              }
              this.eventLog = [];
              this.logEvent({
                message: 'Loaded file "' + filename + '"',
                type: 'info'
              });
              var fileNameMatch = filename.match(/(?:^|\/)([0-9a-f]{5}).*\.svg$/i);
              if (fileNameMatch.length === 2) {
                this.charId = fileNameMatch[1];
                this.handleInput(res);
              }
            });
            window.logEvent = this.logEvent;
          }
        }
      },
      mounted: function () {
        document.addEventListener('dragover', this.onDragOver)
        document.addEventListener('dragleave', this.onDragLeave)
        document.addEventListener('drop', this.onDrop)

        window.addEventListener('hashchange', this.loadFromHash)

        var that = this;
        window.onbeforeunload = function () {
          if (that.isDirty) {
            return 'Unsaved changes will be lost! Continue?';
          }
          return;
        };
        this.loadFromHash();
      },
      beforeDestroy: function () {
        document.removeEventListener('dragover', this.onDragOver)
        document.removeEventListener('dragleave', this.onDragLeave)
        document.removeEventListener('drop', this.onDrop)

        window.removeEventListener('hashchange', this.loadFromHash)
      },
      watch: {
        isDirty: function (val, oldVal) {
          if (!oldVal && !!val) {
            this.logEvent({
              message: 'Changes have been made to the input SVG. You should export this file to apply the fixes.',
              type: 'info'
            })
          }
        }
      }
    }); 
  </script>
</body>

</html>